// =====================================================
// Grammo "all-constructs" test program (syntactically + semantically aligned)
// Goal: maximize grammar alternative coverage + exercise semantic rules
// Notes:
// - No-shadowing: all identifiers are unique across global/local scopes
// - Blocks do NOT introduce a new scope (per project semantics)
// - The test DOES NOT include `for(;;)` as requested
// =====================================================

// -----------------------------
// Top-level variable declarations
// -----------------------------
var int: g_i, g_j, g_k;
var real: g_r1, g_r2;
var bool: g_b1, g_b2;
var string: g_s1, g_s2;

var G_PI = 3.14159;
var G_ANSWER = 42;
var G_FLAG = true;
var G_BANNER = "Grammo front-end test";

// -----------------------------
// Functions / Procedures
// -----------------------------

// Procedure (void): may use `return;` (no expression)
func void -> log(string: lg_msg) {
    // outputln_stmt with io_args containing expr
    <<! lg_msg;

    // outputln_stmt with empty io_args (io_args is *)
    <<!;

    return;
}

// Procedure (void) with no parameters: covers proc_call with arg_list omitted
func void -> ping() {
    <<! "ping";
    return;
}

// Function (int) with no parameters: covers func_call with arg_list omitted
func int -> forty_two() {
    return 42;
}

// Function (int): must return an int expression on all paths
func int -> add(int: add_a, int: add_b) {
    var int: add_res;
    add_res = add_a + add_b;
    return add_res;
}

// Function (real): exercises TIMES, DIV, MINUS, unary MINUS, parentheses
func real -> mix(real: mx_x, real: mx_y) {
    return (mx_x * mx_y) / (mx_x - -mx_y);
}

// Function (string): exercises string concatenation (string + string)
func string -> greet(string: gr_name) {
    var string: gr_prefix, gr_full;
    gr_prefix = "Hi, ";
    gr_full = gr_prefix + gr_name;
    return gr_full;
}

// Function (bool): exercises NOT, AND, OR, EQ, NE, LT, LE, GT, GE
func bool -> complex_bool(bool: cb_p, bool: cb_q, int: cb_n) {
    var bool: cb_r;

    cb_r = (!cb_p && cb_q) || (cb_n == 0) || (cb_n <> 1);
    cb_r = cb_r && (cb_n < 10) && (cb_n <= 10) && (cb_n > -1) && (cb_n >= 0);

    return cb_r;
}

// Non-void function that guarantees return on all paths using if/elif/else
// (exercises semantic "all paths return" check on a non-void function)
func int -> classify(int: cl_n) {
    if (cl_n < 0) {
        return -1;
    }
    elif (cl_n == 0) {
        return 0;
    }
    else {
        return 1;
    }
}

// -----------------------------
// Coverage helpers (grammar alternatives)
// -----------------------------

// Covers multiple if-statement syntactic variants (all semantically valid)
func void -> cover_if_variants(bool: iv_cond, int: iv_n) {
    var int: iv_x;
    iv_x = 0;

    // Variant 1: if without elif and without else
    if (iv_cond) {
        iv_x = iv_x + 1;
    }

    // Variant 2: if with else but without elif
    if (iv_n < 0) {
        iv_x = iv_x + 10;
    }
    else {
        iv_x = iv_x + 20;
    }

    // Variant 3: if with elif but without else
    if (iv_n == 0) {
        iv_x = iv_x + 100;
    }
    elif (iv_n <> 0) {
        iv_x = iv_x + 200;
    }

    << "cover_if_variants iv_x=" # (iv_x);
    return;
}

// Covers: for (init; ; update) with missing condition (terminates via return)
func void -> cover_for_missing_cond(int: fc_limit) {
    var int: fc_i;
    fc_i = 0;

    for (fc_i = 0; ; fc_i = fc_i + 1) {
        if (fc_i >= fc_limit) {
            <<! "cover_for_missing_cond done";
            return;
        }
    }
}

// Covers remaining for_stmt variants (excluding for(;;) by request)
// Ensures termination without break by using conditions and/or return.
func void -> cover_for_variants(int: fv_limit) {
    var int: fv_i, fv_sum;
    fv_i = 0;
    fv_sum = 0;

    // Variant A: for (; cond; update)  [init omitted]
    fv_i = 0;
    for (; fv_i < fv_limit; fv_i = fv_i + 1) {
        fv_sum = fv_sum + fv_i;
    }
    << "forA sum=" # (fv_sum);

    // Variant B: for (init; cond; )  [update omitted]
    fv_sum = 0;
    for (fv_i = 0; fv_i < fv_limit; ) {
        fv_sum = fv_sum + fv_i;
        fv_i = fv_i + 1; // manual update in body
    }
    << "forB sum=" # (fv_sum);

    // Variant C: for (; cond; )  [init + update omitted]
    fv_sum = 0;
    fv_i = 0;
    for (; fv_i < fv_limit; ) {
        fv_sum = fv_sum + fv_i;
        fv_i = fv_i + 1; // manual update in body
    }
    << "forC sum=" # (fv_sum);

    // Variant D: for (init; ; )  [cond + update omitted]
    // Condizione omessa trattata semanticamente come true; termina via return.
    fv_i = 0;
    fv_sum = 0;
    for (fv_i = 0; ; ) {
        if (fv_i >= fv_limit) {
            <<! "forD done";
            return;
        }
        fv_sum = fv_sum + fv_i;
        fv_i = fv_i + 1; // manual update in body
    }
}

// -----------------------------
// Entry point
// -----------------------------
func void -> main() {
    // Local var_decl forms (typed list + const_expr assignment form)
    var int: m_i, m_sum, m_tmp_int, m_class;
    var real: m_acc, m_tmp_real;
    var bool: m_ok;
    var string: m_name, m_msg;

    var M_LOCAL_CONST_INT = 7;
    var M_LOCAL_CONST_REAL = 2.5;
    var M_LOCAL_CONST_BOOL = false;
    var M_LOCAL_CONST_STR = "local";

    // Assignments with literals and vars
    m_i = 0;
    m_sum = 0;
    m_acc = 0.0;
    m_ok = true;
    m_name = "Ada";

    // proc_call statement: only valid for void procedures
    log("Starting...");
    log(G_BANNER);
    ping();

    // Use non-void zero-arg call in expression context
    m_tmp_int = forty_two();
    << "forty_two=" # (m_tmp_int);

    // output_stmt with io_args mixing expr and HASH(LPAR expr RPAR)
    << "name=" # (m_name) "  i=" # (m_i) "  ok=" # (m_ok);

    // output_stmt with only #(expr) segments (no plain expr segments)
    << # (m_name) # (m_i) # (m_ok);

    // output_stmt with empty io_args (grammar alternative)
    <<;

    // input_stmt: prompt segments must be string; #(Expr) must be an assignable ID
    >> "Enter a value for i: " # (m_i);
    <<! "m_i=" # (m_i);

    // input_stmt with prompt as a string expression (still must type-check to string)
    >> greet(m_name) ", enter a value: " # (m_sum);
    <<! "m_sum=" # (m_sum);

    // Nested block statement (blocks do NOT create a new scope per specs)
    {
        var int: m_inner;
        m_inner = 1 + 2 * 3;                // precedence: TIMES before PLUS

        // Use real division to avoid any int/int DIV typing ambiguity
        m_tmp_real = (m_inner + 4) / 2.0;   // parentheses + DIV on reals

        << "inner=" # (m_inner) " tmp_real=" # (m_tmp_real);
    }

    // Also cover int->real promotion on call arguments (int passed to real parameter)
    m_acc = mix(G_PI, m_i);

    // if_stmt with elif_list and else_block (all conditions bool)
    if ((m_i == 0) || (!m_ok && (m_i <> 1))) {
        <<! "Branch: IF";
        m_msg = greet(m_name);              // func_call in expr context
        << "greet=" # (m_msg);
    }
    elif ((m_i > 0) && (m_i < 10)) {
        <<! "Branch: ELIF 1";
        m_sum = add(m_i, 2);
        << "sum=" # (m_sum);
    }
    elif ((m_i >= 10) && (m_i <= 20)) {
        <<! "Branch: ELIF 2";
        m_acc = mix(G_PI, 2.0);
        << "acc=" # (m_acc);
    }
    else {
        <<! "Branch: ELSE";
        m_ok = complex_bool(false, true, m_i);
        << "ok=" # (m_ok);
    }

    // Exercise additional if syntactic variants
    cover_if_variants(m_ok, m_i);

    // while_stmt (condition must be bool)
    while ((m_i < 5) && m_ok) {
        m_sum = m_sum + m_i;
        m_i = m_i + 1;
        m_ok = !false;                      // NOT + FALSE literal
        << "loop i=" # (m_i) " sum=" # (m_sum);
    }

    // for_stmt with all parts present
    for (m_i = 0; m_i < 3; m_i = m_i + 1) {
        m_tmp_int = add(m_i, 1);
        m_sum = m_sum + m_tmp_int;
        << "for_full i=" # (m_i) " sum=" # (m_sum);
    }

    // for_stmt variant: missing condition
    cover_for_missing_cond(2);

    // for_stmt remaining variants (excluding for(;;))
    cover_for_variants(3);

    // Non-void function return-path test usage
    m_class = classify(m_i);
    << "classify=" # (m_class);

    return;
}
